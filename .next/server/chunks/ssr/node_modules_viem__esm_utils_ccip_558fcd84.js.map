{"version":3,"sources":["../../../../node_modules/viem/utils/ccip.ts","../../../../node_modules/viem/utils/abi/decodeFunctionData.ts","../../../../node_modules/viem/utils/abi/encodeErrorResult.ts","../../../../node_modules/viem/utils/abi/encodeFunctionResult.ts","../../../../node_modules/viem/errors/ccip.ts","../../../../node_modules/viem/utils/ens/localBatchGatewayRequest.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n","import type { Abi, AbiStateMutability } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: abi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allFunctionNames extends\n    ContractFunctionName<abi> = ContractFunctionName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [functionName in allFunctionNames]: {\n          args: ContractFunctionArgs<abi, AbiStateMutability, functionName>\n          functionName: functionName\n        }\n      }[allFunctionNames]\n    >\n  : {\n      args: readonly unknown[] | undefined\n      functionName: string\n    }\n\nexport type DecodeFunctionDataErrorType =\n  | AbiFunctionSignatureNotFoundError\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | SliceErrorType\n  | ErrorType\n\nexport function decodeFunctionData<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeFunctionDataParameters<abi>,\n) {\n  const { abi, data } = parameters as DecodeFunctionDataParameters\n  const signature = slice(data, 0, 4)\n  const description = abi.find(\n    (x) =>\n      x.type === 'function' &&\n      signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<abi>\n}\n","import type { Abi, ExtractAbiErrors } from 'abitype'\n\nimport {\n  AbiErrorInputsNotFoundError,\n  AbiErrorNotFoundError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeErrorResult'\n\nexport type EncodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> | undefined = ContractErrorName<abi>,\n  ///\n  hasErrors = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiErrors<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractErrorArgs<\n    abi,\n    errorName extends ContractErrorName<abi>\n      ? errorName\n      : ContractErrorName<abi>\n  >,\n  allErrorNames = ContractErrorName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { errorName?: errorName | allErrorNames | undefined }\n      : { errorName: errorName | allErrorNames }\n    : { errorName?: errorName | allErrorNames | undefined }\n> &\n  (hasErrors extends true ? unknown : never)\n\nexport type EncodeErrorResultReturnType = Hex\n\nexport type EncodeErrorResultErrorType =\n  | GetAbiItemErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | EncodeAbiParametersErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function encodeErrorResult<\n  const abi extends Abi | readonly unknown[],\n  errorName extends ContractErrorName<abi> | undefined = undefined,\n>(\n  parameters: EncodeErrorResultParameters<abi, errorName>,\n): EncodeErrorResultReturnType {\n  const { abi, errorName, args } = parameters as EncodeErrorResultParameters\n\n  let abiItem = abi[0]\n  if (errorName) {\n    const item = getAbiItem({ abi, args, name: errorName })\n    if (!item) throw new AbiErrorNotFoundError(errorName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'error')\n    throw new AbiErrorNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toFunctionSelector(definition)\n\n  let data: Hex = '0x'\n  if (args && args.length > 0) {\n    if (!abiItem.inputs)\n      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath })\n    data = encodeAbiParameters(abiItem.inputs, args)\n  }\n  return concatHex([signature, data])\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionName,\n  ContractFunctionReturnType,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionResult'\n\nexport type EncodeFunctionResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n  result?:\n    | ContractFunctionReturnType<\n        abi,\n        AbiStateMutability,\n        functionName extends ContractFunctionName<abi>\n          ? functionName\n          : ContractFunctionName<abi>,\n        never // allow all args. required for overloads to work.\n      >\n    | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | undefined }\n      : { functionName: functionName | allFunctionNames }\n    : { functionName?: functionName | allFunctionNames | undefined }\n> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionResultReturnType = Hex\n\nexport type EncodeFunctionResultErrorType =\n  | AbiFunctionOutputsNotFoundError\n  | AbiFunctionNotFoundError\n  | EncodeAbiParametersErrorType\n  | GetAbiItemErrorType\n  | ErrorType\n\nexport function encodeFunctionResult<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionResultParameters<abi, functionName>,\n): EncodeFunctionResultReturnType {\n  const { abi, functionName, result } =\n    parameters as EncodeFunctionResultParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({ abi, name: functionName })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = (() => {\n    if (abiItem.outputs.length === 0) return []\n    if (abiItem.outputs.length === 1) return [result]\n    if (Array.isArray(result)) return result\n    throw new InvalidArrayError(result)\n  })()\n\n  return encodeAbiParameters(abiItem.outputs, values)\n}\n","import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import { batchGatewayAbi } from '../../constants/abis.js'\nimport { solidityError } from '../../constants/solidity.js'\nimport type { Hex } from '../../types/misc.js'\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js'\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js'\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js'\nimport type {\n  CcipRequestErrorType,\n  CcipRequestParameters,\n  CcipRequestReturnType,\n} from '../ccip.js'\n\nexport const localBatchGatewayUrl = 'x-batch-gateway:true'\n\nexport async function localBatchGatewayRequest(parameters: {\n  data: Hex\n  ccipRequest: (\n    parameters: CcipRequestParameters,\n  ) => Promise<CcipRequestReturnType>\n}): Promise<Hex> {\n  const { data, ccipRequest } = parameters\n\n  const {\n    args: [queries],\n  } = decodeFunctionData({ abi: batchGatewayAbi, data })\n\n  const failures: boolean[] = []\n  const responses: Hex[] = []\n  await Promise.all(\n    queries.map(async (query, i) => {\n      try {\n        responses[i] = query.urls.includes(localBatchGatewayUrl)\n          ? await localBatchGatewayRequest({ data: query.data, ccipRequest })\n          : await ccipRequest(query)\n        failures[i] = false\n      } catch (err) {\n        failures[i] = true\n        responses[i] = encodeError(err as CcipRequestErrorType)\n      }\n    }),\n  )\n\n  return encodeFunctionResult({\n    abi: batchGatewayAbi,\n    functionName: 'query',\n    result: [failures, responses],\n  })\n}\n\nfunction encodeError(error: CcipRequestErrorType): Hex {\n  if (error.name === 'HttpRequestError' && error.status)\n    return encodeErrorResult({\n      abi: batchGatewayAbi,\n      errorName: 'HttpError',\n      args: [error.status, error.shortMessage],\n    })\n  return encodeErrorResult({\n    abi: [solidityError],\n    errorName: 'Error',\n    args: ['shortMessage' in error ? error.shortMessage : error.message],\n  })\n}\n"],"names":[],"mappings":"uCAEA,IAAA,ECA4C,CAArC,ACAA,ACAA,ACCA,ACHA,ALEA,CGE0B,CFFxB,ACCP,ACAA,ACAO,ACHA,ALEqB,AAAuC,AGGnE,CCF+C,AJDoB,AGGnE,CCF+C,AHDC,CAAqB,CDArC,ACAqC,EDAnC,GIClB,ACHuC,CAAA,CHIlC,AEDH,CJDsB,EEGzC,CGLuB,EFKL,ACFO,ACHA,CFIO,EAEhC,CDD2B,CAAA,CGLI,CFGN,EAGnB,AAFL,CDD2B,EAC3B,IDFwC,EAAE,YEIhB,CAAA,ICKf,CDSC,SCT2B,EAAA,SAAS,CAChD,EDsDI,CA9CgD,CAAA,OHAQ,CCF7B,AEgD3B,AD7C2B,AGjB8B,ALgBD,CIP1D,AFQ6B,ADHA,AId8B,IHkBZ,ADHA,EAAE,ACGA,IFDzB,CKhBC,CHiB8B,ADHA,ADE7B,CKhBC,KDQX,CAAA,MAAA,CACX,MACL,CAAA,WACA,CAAS,AFMkE,ADHA,CCGA,ADHA,OGF3E,CAAA,MACA,CAAI,ACb6D,CDqBlE,ACrBkE,CDqBlE,CACC,CFJ+B,AFD1B,IAAA,CIMH,EAAM,CFLmC,EFDxB,EAAE,EEC4B,KEK7B,CChBS,CJ2CC,2DGzB5B,0BAGQ,EAAA,YAAkB,EAAA,EAAM,CAAC,AAC7B,CF0CK,CAAA,YE1Ca,EAAA,OAAW,GAAK,CJHO,CIGL,CACpC,CCPK,KFkD+C,mBC1CpD,CF0CG,EE1CK,CAAJ,AH+BA,CDlCU,sBIKT,EAAK,GAAG,CAAC,AAAC,GH6B0B,AG7BvB,AAAK,CAAD,CAAF,GAAE,EAAA,CAAA,EAAA,EAAA,MAAA,EAAe,GAAA,CAAM,CAAC,ACNE,eDQjC,EAAM,ACNF,CAAA,AHgDG,AE1CC,CH+BG,EG/BL,YACF,CACjB,CAAA,CCPQ,CFsDH,mBAAA,EC/CmB,CH+BD,CG/BiB,CAAE,CF2CV,AE1ChC,CF0CiC,AE1CjC,CF0CiC,UE3CO,GACxC,EAAA,EAAA,CAA4B,CH+BC,AG9B9B,CAAC,IAAA,iCAKT,MAMY,GJTH,OISgD,EAAA,SAAS,qBACnD,CAAM,CCXD,IDWG,CAAG,CAAA,CAAA,MAClB,CACH,4EAA4E,CAC5E,cACgB,UJXQ,UIYJ,EAAA,MAAA,A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","ignoreList":[0,1,2,3,4,5]}