{"version":3,"sources":["../../../../node_modules/abitype/src/regex.ts","../../../../node_modules/abitype/src/human-readable/formatAbiParameter.ts","../../../../node_modules/abitype/src/human-readable/formatAbiParameters.ts","../../../../node_modules/abitype/src/version.ts","../../../../node_modules/abitype/src/errors.ts","../../../../node_modules/abitype/src/human-readable/errors/abiParameter.ts","../../../../node_modules/abitype/src/human-readable/runtime/signatures.ts","../../../../node_modules/abitype/src/human-readable/errors/abiItem.ts","../../../../node_modules/abitype/src/human-readable/runtime/structs.ts","../../../../node_modules/abitype/src/human-readable/errors/struct.ts","../../../../node_modules/abitype/src/human-readable/errors/splitParameters.ts","../../../../node_modules/abitype/src/human-readable/runtime/utils.ts","../../../../node_modules/abitype/src/human-readable/errors/signature.ts","../../../../node_modules/abitype/src/human-readable/runtime/cache.ts","../../../../node_modules/abitype/src/human-readable/formatAbiItem.ts"],"sourcesContent":["// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array || ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","export const version = '1.2.3'\n","import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n","import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\nexport function execFallbackSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(fallbackSignatureRegex, signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n","import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[] = [],\n  structs: StructLookup = {},\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n","import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n","import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFallbackSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature))\n    return parseFunctionSignature(signature, structs)\n\n  if (isEventSignature(signature))\n    return parseEventSignature(signature, structs)\n\n  if (isErrorSignature(signature))\n    return parseErrorSignature(signature, structs)\n\n  if (isConstructorSignature(signature))\n    return parseConstructorSignature(signature, structs)\n\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\n\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nexport function parseFunctionSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execFunctionSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n  const inputParams = splitParameters(match.parameters)\n  const inputs = []\n  const inputLength = inputParams.length\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(\n      parseAbiParameter(inputParams[i]!, {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function',\n      }),\n    )\n  }\n\n  const outputs = []\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns)\n    const outputLength = outputParams.length\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(\n        parseAbiParameter(outputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n  }\n\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs,\n  }\n}\n\nexport function parseEventSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execEventSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, {\n        modifiers: eventModifiers,\n        structs,\n        type: 'event',\n      }),\n    )\n  return { name: match.name, type: 'event', inputs: abiParameters }\n}\n\nexport function parseErrorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execErrorSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\n    )\n  return { name: match.name, type: 'error', inputs: abiParameters }\n}\n\nexport function parseConstructorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execConstructorSignature(signature)\n  if (!match)\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n    )\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters,\n  }\n}\n\nexport function parseFallbackSignature(signature: string) {\n  const match = execFallbackSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\n\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n  }\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else if (match.type === 'address payable') {\n    type = 'address'\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n","import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport type { StructLookup } from '../types/structs.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type} and {@link structs}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`) and ensures different struct definitions with the same name are cached separately.\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @param structs Struct definitions to include in cache key\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n  structs?: StructLookup,\n) {\n  let structKey = ''\n  if (structs)\n    for (const struct of Object.entries(structs)) {\n      if (!struct) continue\n      let propertyKey = ''\n      for (const property of struct[1]) {\n        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`\n      }\n      structKey += `(${struct[0]}{${propertyKey}})`\n    }\n  if (type) return `${type}:${param}${structKey}`\n  return `${param}${structKey}`\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,8,9,10,11,12,13]}