{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/metta/Fomo4ClawAggregator/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  })\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///home/metta/Fomo4ClawAggregator/lib/dexscreener.ts"],"sourcesContent":["const DEXSCREENER_BASE = 'https://api.dexscreener.com'\n\ninterface DexPair {\n  chainId?: string\n  pairAddress?: string\n  dexId?: string\n  labels?: string[]\n  baseToken?: { address?: string; name?: string; symbol?: string }\n  quoteToken?: { address?: string; name?: string; symbol?: string }\n  priceUsd?: string\n  priceChange?: { h5?: number; h1?: number; h6?: number; h24?: number }\n  priceChange24h?: number\n  volume?: { h24?: number }\n  volume24h?: number\n  liquidity?: { usd?: number }\n  fdv?: number\n  txns?: { h24?: { buys?: number; sells?: number } }\n  info?: { imageUrl?: string }\n}\n\ninterface DexResponse {\n  pairs?: DexPair[] | null\n}\n\nconst DEXSCREENER_FETCH_OPTS: RequestInit = {\n  next: { revalidate: 300 } as const, // 5 min cache\n}\n\nexport async function fetchTokenPairs(\n  address: string\n): Promise<{\n  priceUsd?: string\n  priceChange5m?: number\n  priceChange1h?: number\n  priceChange6h?: number\n  priceChange24h?: number\n  volume24h?: number\n  liquidity?: number\n  fdv?: number\n  txns24h?: number\n} | null> {\n  try {\n    const res = await fetch(`${DEXSCREENER_BASE}/latest/dex/tokens/${address}`, DEXSCREENER_FETCH_OPTS)\n    if (!res.ok) return null\n\n    const data: DexResponse = await res.json()\n    const pairs = data?.pairs ?? []\n\n    const basePair = pairs.find((p) => p.chainId === 'base') ?? pairs[0]\n    if (!basePair) return null\n\n    const buys = basePair.txns?.h24?.buys ?? 0\n    const sells = basePair.txns?.h24?.sells ?? 0\n    const txns24h = buys + sells || undefined\n\n    return {\n      priceUsd: basePair.priceUsd,\n      priceChange5m: basePair.priceChange?.h5,\n      priceChange1h: basePair.priceChange?.h1,\n      priceChange6h: basePair.priceChange?.h6,\n      priceChange24h: basePair.priceChange?.h24 ?? basePair.priceChange24h,\n      volume24h: basePair.volume?.h24 ?? basePair.volume24h,\n      liquidity: basePair.liquidity?.usd,\n      fdv: basePair.fdv,\n      txns24h,\n    }\n  } catch {\n    return null\n  }\n}\n\n/**\n * Parse DexScreener URL e.g. https://dexscreener.com/base/0x123\n * Supports both token (40 hex) and pair/pool (64 hex) addresses\n * Returns { chainId, address, isPair } or null\n */\nexport function parseDexScreenerUrl(url: string): { chainId: string; address: string; isPair: boolean } | null {\n  try {\n    // Token: 0x + 40 hex chars. Pair (Uniswap V4 etc): 0x + 64 hex chars\n    const match = url.match(/dexscreener\\.com\\/([^/]+)\\/(0x[a-fA-F0-9]{40,64})/)\n    if (!match) return null\n    const address = match[2]\n    const isPair = address.length === 66 // 0x + 64 hex = pair address\n    return { chainId: match[1].toLowerCase(), address, isPair }\n  } catch {\n    return null\n  }\n}\n\n/**\n * Fetch token/pair info from DexScreener URL for submission\n * Supports both token URLs (dexscreener.com/base/0xTOKEN) and pair URLs (dexscreener.com/base/0xPAIR...)\n */\nexport async function fetchPairFromUrl(\n  url: string\n): Promise<{\n  tokenAddress: string\n  pairAddress?: string\n  name: string\n  symbol: string\n  quoteSymbol?: string\n  quoteAddress?: string\n  labels?: string[]\n  dexId?: string\n  image?: string\n  chainId: string\n  priceUsd?: string\n  volume24h?: number\n} | null> {\n  const parsed = parseDexScreenerUrl(url)\n  if (!parsed) return null\n\n  const { chainId, address, isPair } = parsed\n\n  let basePair: DexPair | null = null\n\n  if (isPair) {\n    // Pair URL: use /pairs/{chainId}/{pairAddress} endpoint\n    const res = await fetch(\n      `https://api.dexscreener.com/latest/dex/pairs/${chainId}/${address}`,\n      { cache: 'no-store' }\n    )\n    if (!res.ok) return null\n    const data = await res.json()\n    // Pairs endpoint returns { pairs: [...] } (array, often 1 item)\n    const pairs = data?.pairs ?? (Array.isArray(data) ? data : [data])\n    basePair = pairs.find((p: DexPair) => p.chainId === chainId) ?? pairs[0] ?? null\n  } else {\n    // Token URL: use /tokens/{address} endpoint\n    const res = await fetch(\n      `https://api.dexscreener.com/latest/dex/tokens/${address}`,\n      { cache: 'no-store' }\n    )\n    if (!res.ok) return null\n    const data = await res.json()\n    const pairs = data?.pairs ?? []\n    basePair = pairs.find((p: DexPair) => p.chainId === chainId) ?? pairs[0] ?? null\n  }\n\n  if (!basePair) return null\n\n  const tokenAddress = basePair.baseToken?.address ?? address\n  // Pair pages: use info.imageUrl (shows both tokens). Token pages: fallback to token icon CDN\n  const image =\n    basePair.info?.imageUrl ??\n    (tokenAddress ? `https://cdn.dexscreener.com/token-icons/${tokenAddress.toLowerCase()}.png` : undefined)\n\n  return {\n    tokenAddress,\n    pairAddress: basePair.pairAddress,\n    name: basePair.baseToken?.name ?? 'Unknown',\n    symbol: basePair.baseToken?.symbol ?? '???',\n    quoteSymbol: basePair.quoteToken?.symbol,\n    quoteAddress: basePair.quoteToken?.address,\n    labels: basePair.labels,\n    dexId: basePair.dexId,\n    image,\n    chainId: basePair.chainId ?? chainId,\n    priceUsd: basePair.priceUsd,\n    volume24h: basePair.volume?.h24 ?? basePair.volume24h,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///home/metta/Fomo4ClawAggregator/app/api/tokens/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { prisma } from '@/lib/db'\nimport { fetchTokenPairs, fetchPairFromUrl } from '@/lib/dexscreener'\n\ntype TokenWithMarket = {\n  address: string\n  name: string\n  symbol: string\n  quoteSymbol?: string\n  pairLabel?: string\n  image: string | null\n  source: 'community'\n  clankerUrl: undefined\n  explorerUrl: string\n  dexScreenerUrl: string\n  createdAt: string\n  marketData: Awaited<ReturnType<typeof fetchTokenPairs>> | undefined\n}\n\ntype PairInfo = {\n  image?: string\n  quoteSymbol?: string\n  labels?: string[]\n}\n\nconst MIN_VOLUME = 1\nconst MAX_TOKENS_TO_FETCH = 50 // limit DexScreener calls\nconst DEXSCREENER_CONCURRENCY = 10\nconst CACHE_TTL_MS = 5 * 60 * 1000\nconst marketCache = new Map<\n  string,\n  { data: NonNullable<Awaited<ReturnType<typeof fetchTokenPairs>>>; expires: number }\n>()\nconst pairInfoCache = new Map<string, { data: PairInfo; expires: number }>()\n\nfunction getCached(address: string) {\n  const e = marketCache.get(address.toLowerCase())\n  if (!e || Date.now() > e.expires) return undefined\n  return e.data\n}\n\nfunction setCached(address: string, data: NonNullable<Awaited<ReturnType<typeof fetchTokenPairs>>>) {\n  marketCache.set(address.toLowerCase(), { data, expires: Date.now() + CACHE_TTL_MS })\n}\n\nasync function runWithConcurrency<T, R>(\n  items: T[],\n  fn: (item: T) => Promise<R>,\n  concurrency: number\n): Promise<R[]> {\n  const results: R[] = []\n  for (let i = 0; i < items.length; i += concurrency) {\n    const chunk = items.slice(i, i + concurrency)\n    const chunkResults = await Promise.all(chunk.map(fn))\n    results.push(...chunkResults)\n  }\n  return results\n}\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const minVolume = parseFloat(searchParams.get('minVolume') ?? '1') || 1\n    const limit = Math.min(parseInt(searchParams.get('limit') ?? '20', 10) || 20, 100)\n    const offset = Math.max(parseInt(searchParams.get('offset') ?? '0', 10) || 0, 0)\n    const sort = (searchParams.get('sort') ?? 'trending') as\n      | 'trending'\n      | 'new'\n      | 'gainers'\n      | 'mcap'\n      | 'volume'\n\n    const approved = await prisma.submission.findMany({\n      where: { status: 'approved' },\n      include: { votes: true },\n      orderBy: { approvedAt: 'desc' },\n      take: MAX_TOKENS_TO_FETCH,\n    })\n\n    // Fast path: no tokens â†’ return immediately (no DexScreener calls)\n    if (approved.length === 0) {\n      return NextResponse.json({\n        tokens: [],\n        total: 0,\n        totalVolume: 0,\n        totalTxns: 0,\n      })\n    }\n\n    const fetchOne = async (s: { tokenAddress: string; name: string; symbol: string; image: string | null; dexScreenerUrl: string; createdAt: Date }) => {\n      let market = getCached(s.tokenAddress)\n      if (!market) {\n        market = await fetchTokenPairs(s.tokenAddress) ?? undefined\n        if (market) setCached(s.tokenAddress, market)\n      }\n\n      // Fetch full pair info (image, quoteSymbol, labels) from DexScreener URL\n      let image = s.image\n      let quoteSymbol: string | undefined\n      let pairLabel: string | undefined\n      if (s.dexScreenerUrl) {\n        const cached = pairInfoCache.get(s.dexScreenerUrl)\n        if (cached && Date.now() < cached.expires) {\n          image = cached.data.image ?? image\n          quoteSymbol = cached.data.quoteSymbol\n          pairLabel = cached.data.labels?.[0]\n        } else {\n          const pairInfo = await fetchPairFromUrl(s.dexScreenerUrl)\n          if (pairInfo) {\n            if (pairInfo.image?.includes('/cms/images')) image = pairInfo.image\n            quoteSymbol = pairInfo.quoteSymbol\n            pairLabel = pairInfo.labels?.[0]\n            pairInfoCache.set(s.dexScreenerUrl, {\n              data: { image: image ?? undefined, quoteSymbol, labels: pairInfo.labels },\n              expires: Date.now() + CACHE_TTL_MS,\n            })\n          }\n        }\n      }\n      if (!image) image = `https://cdn.dexscreener.com/token-icons/${s.tokenAddress.toLowerCase()}.png`\n\n      return {\n        address: s.tokenAddress,\n        name: s.name,\n        symbol: s.symbol,\n        quoteSymbol,\n        pairLabel,\n        image,\n        source: 'community' as const,\n        clankerUrl: undefined,\n        explorerUrl: `https://basescan.org/token/${s.tokenAddress}`,\n        dexScreenerUrl: s.dexScreenerUrl,\n        createdAt: s.createdAt.toISOString(),\n        marketData: market,\n      }\n    }\n\n    const withMarket = await runWithConcurrency(\n      approved,\n      fetchOne,\n      DEXSCREENER_CONCURRENCY\n    )\n\n    const filtered = (withMarket as TokenWithMarket[]).filter(\n      (t: TokenWithMarket) => (t.marketData?.volume24h ?? 0) > minVolume\n    )\n\n    const ts = (t: TokenWithMarket) => new Date(t.createdAt).getTime()\n    const sorted = [...filtered].sort((a, b) => {\n      const m1 = a.marketData\n      const m2 = b.marketData\n      switch (sort) {\n        case 'trending':\n          return (\n            (m2?.priceChange6h ?? m2?.priceChange24h ?? -Infinity) -\n            (m1?.priceChange6h ?? m1?.priceChange24h ?? -Infinity)\n          )\n        case 'new':\n          return ts(b) - ts(a)\n        case 'gainers':\n          return (m2?.priceChange24h ?? -Infinity) - (m1?.priceChange24h ?? -Infinity)\n        case 'mcap':\n          return (m2?.fdv ?? 0) - (m1?.fdv ?? 0)\n        case 'volume':\n          return (m2?.volume24h ?? 0) - (m1?.volume24h ?? 0)\n        default:\n          return 0\n      }\n    })\n\n    const total = sorted.length\n    const totalVolume = sorted.reduce((acc: number, t: TokenWithMarket) => acc + (t.marketData?.volume24h ?? 0), 0)\n    const totalTxns = sorted.reduce((acc: number, t: TokenWithMarket) => acc + (t.marketData?.txns24h ?? 0), 0)\n    const page = sorted.slice(offset, offset + limit)\n\n    return NextResponse.json({\n      tokens: page,\n      total,\n      totalVolume,\n      totalTxns,\n    })\n  } catch (e) {\n    console.error('Tokens API error:', e)\n    return NextResponse.json(\n      { error: 'Failed to fetch tokens', details: String(e) },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}